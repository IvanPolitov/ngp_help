[{"model": "admin.logentry", "pk": 1, "fields": {"action_time": "2024-07-30T15:08:03.184Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "123", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 2, "fields": {"action_time": "2024-07-30T15:08:05.649Z", "user": 1, "content_type": 8, "object_id": "1", "object_repr": "md1", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 3, "fields": {"action_time": "2024-07-30T15:08:25.321Z", "user": 1, "content_type": 8, "object_id": "2", "object_repr": "md2", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 4, "fields": {"action_time": "2024-07-30T15:08:57.565Z", "user": 1, "content_type": 8, "object_id": "3", "object_repr": "md3", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "auth.permission", "pk": 1, "fields": {"name": "Can add log entry", "content_type": 1, "codename": "add_logentry"}}, {"model": "auth.permission", "pk": 2, "fields": {"name": "Can change log entry", "content_type": 1, "codename": "change_logentry"}}, {"model": "auth.permission", "pk": 3, "fields": {"name": "Can delete log entry", "content_type": 1, "codename": "delete_logentry"}}, {"model": "auth.permission", "pk": 4, "fields": {"name": "Can view log entry", "content_type": 1, "codename": "view_logentry"}}, {"model": "auth.permission", "pk": 5, "fields": {"name": "Can add permission", "content_type": 2, "codename": "add_permission"}}, {"model": "auth.permission", "pk": 6, "fields": {"name": "Can change permission", "content_type": 2, "codename": "change_permission"}}, {"model": "auth.permission", "pk": 7, "fields": {"name": "Can delete permission", "content_type": 2, "codename": "delete_permission"}}, {"model": "auth.permission", "pk": 8, "fields": {"name": "Can view permission", "content_type": 2, "codename": "view_permission"}}, {"model": "auth.permission", "pk": 9, "fields": {"name": "Can add group", "content_type": 3, "codename": "add_group"}}, {"model": "auth.permission", "pk": 10, "fields": {"name": "Can change group", "content_type": 3, "codename": "change_group"}}, {"model": "auth.permission", "pk": 11, "fields": {"name": "Can delete group", "content_type": 3, "codename": "delete_group"}}, {"model": "auth.permission", "pk": 12, "fields": {"name": "Can view group", "content_type": 3, "codename": "view_group"}}, {"model": "auth.permission", "pk": 13, "fields": {"name": "Can add user", "content_type": 4, "codename": "add_user"}}, {"model": "auth.permission", "pk": 14, "fields": {"name": "Can change user", "content_type": 4, "codename": "change_user"}}, {"model": "auth.permission", "pk": 15, "fields": {"name": "Can delete user", "content_type": 4, "codename": "delete_user"}}, {"model": "auth.permission", "pk": 16, "fields": {"name": "Can view user", "content_type": 4, "codename": "view_user"}}, {"model": "auth.permission", "pk": 17, "fields": {"name": "Can add content type", "content_type": 5, "codename": "add_contenttype"}}, {"model": "auth.permission", "pk": 18, "fields": {"name": "Can change content type", "content_type": 5, "codename": "change_contenttype"}}, {"model": "auth.permission", "pk": 19, "fields": {"name": "Can delete content type", "content_type": 5, "codename": "delete_contenttype"}}, {"model": "auth.permission", "pk": 20, "fields": {"name": "Can view content type", "content_type": 5, "codename": "view_contenttype"}}, {"model": "auth.permission", "pk": 21, "fields": {"name": "Can add session", "content_type": 6, "codename": "add_session"}}, {"model": "auth.permission", "pk": 22, "fields": {"name": "Can change session", "content_type": 6, "codename": "change_session"}}, {"model": "auth.permission", "pk": 23, "fields": {"name": "Can delete session", "content_type": 6, "codename": "delete_session"}}, {"model": "auth.permission", "pk": 24, "fields": {"name": "Can view session", "content_type": 6, "codename": "view_session"}}, {"model": "auth.permission", "pk": 25, "fields": {"name": "Can add Категория", "content_type": 7, "codename": "add_category"}}, {"model": "auth.permission", "pk": 26, "fields": {"name": "Can change Категория", "content_type": 7, "codename": "change_category"}}, {"model": "auth.permission", "pk": 27, "fields": {"name": "Can delete Категория", "content_type": 7, "codename": "delete_category"}}, {"model": "auth.permission", "pk": 28, "fields": {"name": "Can view Категория", "content_type": 7, "codename": "view_category"}}, {"model": "auth.permission", "pk": 29, "fields": {"name": "Can add Руководство", "content_type": 8, "codename": "add_manual"}}, {"model": "auth.permission", "pk": 30, "fields": {"name": "Can change Руководство", "content_type": 8, "codename": "change_manual"}}, {"model": "auth.permission", "pk": 31, "fields": {"name": "Can delete Руководство", "content_type": 8, "codename": "delete_manual"}}, {"model": "auth.permission", "pk": 32, "fields": {"name": "Can view Руководство", "content_type": 8, "codename": "view_manual"}}, {"model": "auth.user", "pk": 1, "fields": {"password": "pbkdf2_sha256$720000$oWumTFErXRAEcbum7FdOUq$v47HCBmXAAQHtgdJdAC2KDEk45LL99jRZkQXHv3sA1g=", "last_login": "2024-07-30T15:07:16.318Z", "is_superuser": true, "username": "1", "first_name": "", "last_name": "", "email": "", "is_staff": true, "is_active": true, "date_joined": "2024-07-28T18:30:29.193Z", "groups": [], "user_permissions": []}}, {"model": "contenttypes.contenttype", "pk": 1, "fields": {"app_label": "admin", "model": "logentry"}}, {"model": "contenttypes.contenttype", "pk": 2, "fields": {"app_label": "auth", "model": "permission"}}, {"model": "contenttypes.contenttype", "pk": 3, "fields": {"app_label": "auth", "model": "group"}}, {"model": "contenttypes.contenttype", "pk": 4, "fields": {"app_label": "auth", "model": "user"}}, {"model": "contenttypes.contenttype", "pk": 5, "fields": {"app_label": "contenttypes", "model": "contenttype"}}, {"model": "contenttypes.contenttype", "pk": 6, "fields": {"app_label": "sessions", "model": "session"}}, {"model": "contenttypes.contenttype", "pk": 7, "fields": {"app_label": "manual", "model": "category"}}, {"model": "contenttypes.contenttype", "pk": 8, "fields": {"app_label": "manual", "model": "manual"}}, {"model": "sessions.session", "pk": "uo7ou4kysus7hx8j3unb70sn403b7n4l", "fields": {"session_data": ".eJxVjDsOwjAQBe_iGlne-BtKes5g7XptHECOFCcV4u4QKQW0b2beS0Tc1hq3npc4sTgLEKffjTA9ctsB37HdZpnmti4TyV2RB-3yOnN-Xg7376Bir986G1DFWLagnGYVCo6M3nECkzkREI1DCorC4FEV70uyGkhnQKcLYBDvD-4xOEs:1sYoRY:JSDWB2RBTEEBXM3lAlngpB_9lWrgMan3u7tZ8oN7SVs", "expire_date": "2024-08-13T15:07:16.409Z"}}, {"model": "manual.manual", "pk": 1, "fields": {"name": "md1", "content": "# Определение\r\n\r\nБинарный поиск существенно быстрее, чем обычный (см. раздел «Алгоритмы»), но требует предварительной сортировки коллекции, по которой осуществляется поиск.\r\n\r\nЕсть [мнение](https://habr.com/ru/companies/ispsystem/articles/779224/), что бинарный поиск со всеми его особенностями и краевыми случаями — идеальная основа для собеседования, алгоритм, который при постепенном введении дополнительных условий хорошо отражает уровень подготовки кандидата. Так что присмотритесь к bisect и его конкретным реализациям повнимательнее.\r\n\r\n```python\r\nimport bisect\r\n\r\na: list[int] = [12, 6, 8, 19, 1, 33]\r\n\r\na.sort()\r\nprint(f\"Sorted: {a}\")\r\n\r\nprint(bisect.bisect(a, 20))  # Найти индекс для потенциальной вставки\r\n\r\nbisect.insort(a, 15)  # Вставка значения в отсортированную последовательность\r\nprint(a)\r\n\r\n# Бинарный поиск\r\n\r\ndef binary_search(a, x, lo=0, hi=None):\r\n    if hi is None:\r\n        hi = len(a)\r\n\r\n    pos = bisect.bisect_left(a, x, lo, hi)\r\n    return pos if pos != hi and a[pos] == x else -1\r\n\r\nprint(binary_search(a, 15))\r\n```\r\n\r\n```\r\nSorted: [1, 6, 8, 12, 19, 33]\r\n5\r\n[1, 6, 8, 12, 15, 19, 33]\r\n4\r\n```", "created_at": "2024-07-30T15:08:05.646Z", "updated_at": "2024-07-30T15:08:05.646Z", "category": 1, "creator": 1}}, {"model": "manual.manual", "pk": 2, "fields": {"name": "md2", "content": "Подход позволяет укорить процесс вычисления за счет сохранения результатов выполнения подзадач.\r\n\r\n# Основные идеи\r\n- **Переиспользование решений подзадач** — использование уже найденных решений, чтобы построить решение для более крупной задачи\r\n- **Мемоизация** — результаты выполнения функции сохраняются и повторно используются при последующих вызовах с теми же входными данными\r\n- **Табуляция** — решение задачи строится снизу вверх: сначала вычисляются решения для всех малых подзадач, а они ,в свою очередь, используются для решения боле крупных задач.\r\n\r\n# Пример\r\nНа примере нахождения числа Фибоначчи:\r\n```python\r\nfrom functools import lru_cache\r\n\r\n@lru_cache(maxsize=None)\r\ndef fibonacci(n):\r\n\tif n < 2:\r\n\t\treturn n\r\n\treturn fibonacci(n-1) + fibonacci(n-2)\r\n```\r\nНахождение числа методом рекурсии может быть не оптимизированным при больших n в связи с нахождением одних и тех же элементов снова и снова. Но если мы используем декоратор `lru_cache`, благодаря которому будут кэшироваться результаты функций, вызванных с одними и теми же параметрами, работа программы ускорится.\r\n\r\nТак же мы можем использовать табулирование. \r\n```python\r\ndef fibonacci(n):\r\n\tif n == 0:\r\n\t\treturn 0\r\n\tif n == 1:\r\n\t\treturn 1\r\n\r\n\t# инициализация таблицы с базовыми значениями\r\n\ttable = [0] * (n + 1)\r\n\ttable[1] = 1\r\n\r\n\t# заполнение таблицы значенями\r\n\tfor i in range(2, n + 1):\r\n\t\ttable[i] = table[i - 1] + table [i - 2]\r\n\r\n\treturn table[n]\r\n```", "created_at": "2024-07-30T15:08:25.319Z", "updated_at": "2024-07-30T15:08:25.319Z", "category": 1, "creator": 1}}, {"model": "manual.manual", "pk": 3, "fields": {"name": "md3", "content": "# Определение\r\nСтрока – упорядоченная иммутабельная последовательность, использующая кодировку Unicode.\r\n\r\n| **Экранированная последовательность** | **Назначение**                                      |\r\n| ------------------------------------- | --------------------------------------------------- |\r\n| \\n                                    | Перевод строки                                      |\r\n| \\a                                    | Звонок                                              |\r\n| \\b                                    | Забой                                               |\r\n| \\f                                    | Перевод страницы                                    |\r\n| \\r                                    | Возврат каретки                                     |\r\n| \\t                                    | Горизонтальная табуляция                            |\r\n| \\v                                    | Вертикальная табуляция                              |\r\n| \\N{id}                                | Идентификатор ID базы данных Юникода                |\r\n| \\uhhhh                                | 16-битовый символ Юникода в 16-ричном представлении |\r\n| \\Uhhhh                                | 32-битовый символ Юникода в 32-ричном представлении |\r\n| \\xhh                                  | 16-ричное значение символа                          |\r\n| \\ooo                                  | 8-ричное значение символа                           |\r\n| \\0                                    | Символ Null (не является признаком конца строки)    |\r\n\r\n| **Метод**                                 | **Что делает**                                                                                                                                                                                                |\r\n| ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| **S = \"s\\np\\ta\\nbbb\"**                    | Экранированные последовательности                                                                                                                                                                             |\r\n| **S = r\"C:\\temp\\new\"**                    | Неформатированные строки (подавляют экранирование)                                                                                                                                                            |\r\n| **S = b\"byte\"**                           | Строка байтов                                                                                                                                                                                                 |\r\n| **S1 + S2**                               | Конкатенация (сложение строк)                                                                                                                                                                                 |\r\n| **S1 * 3**                                | Повторение строки                                                                                                                                                                                             |\r\n| **S[i]**                                  | Обращение по индексу                                                                                                                                                                                          |\r\n| **S[i:j:step]**                           | Извлечение среза                                                                                                                                                                                              |\r\n| **len(S)**                                | Длина строки                                                                                                                                                                                                  |\r\n| **S.find(str, [start],[end])**            | Поиск подстроки в строке. Возвращает номер первого вхождения или -1                                                                                                                                           |\r\n| **S.rfind(str, [start],[end])**           | Поиск подстроки в строке. Возвращает номер последнего вхождения или -1                                                                                                                                        |\r\n| **S.index(str, [start],[end])**           | Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError                                                                                                                          |\r\n| **S.rindex(str, [start],[end])**          | Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError                                                                                                                       |\r\n| **S.replace(шаблон, замена[, maxcount])** | Замена шаблона на замену. maxcount ограничивает количество замен                                                                                                                                              |\r\n| **S.split(символ)**                       | Разбиение строки по разделителю                                                                                                                                                                               |\r\n| **S.isdigit()**                           | Состоит ли строка из цифр                                                                                                                                                                                     |\r\n| **S.isalpha()**                           | Состоит ли строка из букв                                                                                                                                                                                     |\r\n| **S.isalnum()**                           | Состоит ли строка из цифр или букв                                                                                                                                                                            |\r\n| **S.islower()**                           | Состоит ли строка из символов в нижнем регистре                                                                                                                                                               |\r\n| **S.isupper()**                           | Состоит ли строка из символов в верхнем регистре                                                                                                                                                              |\r\n| **S.isspace()**                           | Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\\f'), \"новая строка\" ('\\n'), \"перевод каретки\" ('\\r'), \"горизонтальная табуляция\" ('\\t') и \"вертикальная табуляция\" ('\\v'))  |\r\n| **S.istitle()**                           | Начинаются ли слова в строке с заглавной буквы                                                                                                                                                                |\r\n| **S.upper()**                             | Преобразование строки к верхнему регистру                                                                                                                                                                     |\r\n| **S.lower()**                             | Преобразование строки к нижнему регистру                                                                                                                                                                      |\r\n| **S.startswith(str)**                     | Начинается ли строка S с шаблона str                                                                                                                                                                          |\r\n| **S.endswith(str)**                       | Заканчивается ли строка S шаблоном str                                                                                                                                                                        |\r\n| **S.join(список)**                        | Сборка строки из списка с разделителем S                                                                                                                                                                      |\r\n| **ord(символ)**                           | Символ в его код ASCII                                                                                                                                                                                        |\r\n| **chr(число)**                            | Код ASCII в символ                                                                                                                                                                                            |\r\n| **S.capitalize()**                        | Переводит первый символ строки в верхний регистр, а все остальные в нижний                                                                                                                                    |\r\n| **S.center(width, [fill])**               | Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)                                                                                                                    |\r\n| **S.count(str, [start],[end])**           | Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)                                                                                        |\r\n| **S.expandtabs([tabsize])**               | Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам |\r\n| **S.lstrip([chars])**                     | Удаление пробельных символов в начале строки                                                                                                                                                                  |\r\n| **S.rstrip([chars])**                     | Удаление пробельных символов в конце строки                                                                                                                                                                   |\r\n| **S.strip([chars])**                      | Удаление пробельных символов в начале и в конце строки                                                                                                                                                        |\r\n| **S.partition(шаблон)**                   | Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки                   |\r\n| **S.rpartition(sep)**                     | Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку                |\r\n| **S.swapcase()**                          | Переводит символы нижнего регистра в верхний, а верхнего – в нижний                                                                                                                                           |\r\n| **S.title()**                             | Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний                                                                                                                              |\r\n| **S.zfill(width)**                        | Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями                                                                                                                         |\r\n| **S.ljust(width, fillchar=\" \")**          | Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar                                                                                                           |\r\n| **S.rjust(width, fillchar=\" \")**          | Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar                                                                                                              |\r\n| **S.format(*args, kwargs)**               | Форматирование строки                                                                                                                                                                                         |\r\n```python\r\nse: str = \"\"  # Пустая строка\r\nsi: str = str(12345)  # Создает строку из числа\r\nsj: str = \" \".join([\"Follow\", \"the\", \"white\", \"rabbit\"])  # Собирает строку из кусочков, используя указанный сепаратор\r\nprint(f\"Joined string: {sj}\")\r\n\r\nis_contains: bool = \"rabbit\" in sj  # Проверка наличия подстроки\r\nis_startswith = sj.startswith(\"Foll\")\r\nis_endswith = sj.endswith(\"bbit\")\r\nprint(f\"is_contains = {is_contains}, is_startswith = {is_startswith}, is_endswith = {is_endswith}\")\r\n\r\nsr: str  = sj.replace(\"rabbit\", \"sheep\")  # Замена подстроки. Можно указать количество замен: sr: str  = sj.replace(\"rabbit\", \"sheep\", times)\r\nprint(f\"After replace: {sr}\")\r\n\r\ni1 = sr.find(\"rabbit\")  # Возвращает стартовый индекс первого вхождения или -1. Есть еще rfind(), начинающий искать с конца строки\r\ni2 = sr.index(\"sheep\")  #  Возвращает стартовый индекс первого вхождения или выкидывает ValueError. Есть еще rindex(), начинающий искать с конца строки\r\nprint(f\"Start index of 'rabbit' is {i1}, start index of 'sheep' is {i2}\")\r\n\r\nd = str.maketrans({\"a\" : \"x\", \"b\" : \"y\", \"c\" : \"z\"})\r\nst  = \"abc\".translate(d)\r\nprint(f\"Translate string: {st}\")\r\n\r\nsr = sj[::-1]  # Реверс через slice с отрицательным шагом\r\nprint(f\"Reverse string: {sr}\")\r\n```\r\n\r\n```\r\nJoined string: Follow the white rabbit\r\nis_contains = True, is_startswith = True, is_endswith = True\r\nAfter replace: Follow the white sheep\r\nStart index of 'rabbit' is -1, start index of 'sheep' is 17\r\nTranslate string: xyz\r\nReverse string: tibbar etihw eht wolloF\r\n```\r\n# Заметки\r\n`isdecimal()` Когда мы проверяем число с точкой, то точкой является только символ `\\u0660` => 45.2 это `45\\u06602`. Метод не проверяет валидность.", "created_at": "2024-07-30T15:08:57.562Z", "updated_at": "2024-07-30T15:08:57.562Z", "category": 1, "creator": 1}}, {"model": "manual.manual", "pk": 4, "fields": {"name": "Any-all", "content": "# Определение\n**any()** вернет True, если хотя бы один элемент итерируемой коллекции истинен, **all()** вернет True только в случае истинности всех элементов коллекции.\n\n```python\nanimals = [\"Squirrel\", \"Beaver\", \"Fox\"]\nsentence = \"Bison likes squirrels and beavers\"\n\nany_animal: bool = any(animal.lower() in sentence.lower() for animal in animals)\nprint(any_animal)\n\nall_animal: bool = all(animal.lower() in sentence.lower() for animal in animals)\nprint(all_animal)\n```\n\n```\nTrue\nFalse\n```", "created_at": "2024-08-02T14:38:46.780Z", "updated_at": "2024-08-02T14:38:46.879Z", "category": 1, "creator": 1}}, {"model": "manual.manual", "pk": 5, "fields": {"name": "API", "content": "# Определение\n**API (Application programming interface)** — он же, программный интерфейс приложения, правила взаимодействия программ друг с другом. Его внутренняя логика скрыта, но в центре внимания находится именно конечный результат взаимодействия и правила, по которым оно организуется.\n\n[GitHub-репозиторий](https://github.com/public-apis/public-apis) с публичными API.\n\nОсновное преимущество API — это экономия ресурсов путем использования уже разработанного функционала.\n# Типы API\nREST API являются популярным выбором благодаря своей простоте и широкому распространению. \nSOAP API хорошо работают в энтерпрайз-средах благодаря своим функциям безопасности. \nWebSocket API отлично подходят для приложений реального времени\ngRPC API — для высокопроизводительных [[Микросервис|микросервисов]]\nAPI GraphQL обеспечивают гибкий поиск данных, что отлично подходит для сложных систем.\n## Сравнительная таблица\n\n|                            | [[REST]] API                                                              | [[SOAP]] API                                             | [[websocket]] API                                                                 | [[gRPC]] API                                                          | [[GraphQL]] API                                                            |\n| -------------------------- | ------------------------------------------------------------------------- | -------------------------------------------------------- | --------------------------------------------------------------------------------- | --------------------------------------------------------------------- | -------------------------------------------------------------------------- |\n| **Формат данных**          | Как правило, [[JSON]], но может поддерживать несколько форматов           | [[XML]]                                                  | Обычно [[JSON]], но может быть любой тип данных                                   | [[Protocol Buffers]] (бинарный формат)                                | [[JSON]]                                                                   |\n| **Протокол**               | [[HTTP]]/[[HTTPS]]                                                        | HTTP/HTTPS, [[SMTP]], XMPP, и другие                     | WS/WSS (WebSocket secure)                                                         | [[HTTP2]]                                                             | [[HTTP]]/[[HTTPS]]                                                         |\n| **Тип связи**              | Односторонняя связь (запрос/ответ)                                        | Односторонняя связь (запрос/ответ)                       | Двусторонняя связь (полный дуплекс)                                               | Двунаправленная потоковая передача                                    | Односторонняя связь (запрос/ответ)                                         |\n| **Service Discovery**      | Не стандартизированы, часто используют OpenAPI (Swagger) для документации | Стандартизация с помощью WSDL                            | Не стандартизировано                                                              | Не стандартизирован, но поддерживает Server Reflection                | Не стандартизировано, интроспекция для обнаружения схем                    |\n| **Производительность**     | Варьируется, обычно ниже, чем бинарные протоколы из-за текстовой природы  | Снижена из-за словесного формата XML                     | Выше благодаря полнодуплексной связи и отсутствию накладных расходов HTTP         | Высокий (бинарный протокол, преимущества HTTP/2)                      | Варьируется, эффективная загрузка данных может повысить производительность |\n| **Сценарий использования** | Общее назначение, широкое применение                                      | Распределенные энтерпрайз- среды, унаследованные системы | Приложения в режиме реального времени, когда серверу необходимо пушить обновления | [[Микросервис\\|Микросервис]], системы, критичные к производительности | Когда требуется гибкая и эффективная загрузка данных                       |\n| **Сложность**              | От низкого до умеренного                                                  | Высокая                                                  | Умеренная                                                                         | От умеренной до высокой                                               | Умеренная                                                                  |\n## Тестирование\n### REST API\n- REST API не используют хранение состояния и могут быть протестированы индивидуально для каждого эндпоинта.\n- Поскольку REST API обычно используют HTTP, в этих случаях обычно применяются такие инструменты, как Postman, Curl или REST-assured (на Java).\n- Каждый эндпоинт тестируется с помощью различных HTTP-методов (GET, POST, PUT, DELETE и т.д.), и проверки делаются в отношении кода состояния, времени ответа и тела ответа.\n\nТестировать REST API с помощью Postman несложно. Поскольку REST API использует HTTP-протоколы, вы можете легко отправлять запросы к эндпоинтам, используя такие методы, как GET, POST, PUT, DELETE и т. д. Postman дает возможности проставить заголовки, тело запроса, параметры запроса и позволяет создавать окружения для управления переменными.\n\nШпаргалка для тестировщика:\n1. **Тестирование** эндпоинтов: Убедитесь, что каждый эндпоинт ведет себя так, как ожидается при правильных входных данных.\n2. **Коды состояния HTTP**: Убедитесь, что в различных ситуациях возвращаются правильные коды состояния.\n3. **Обработка ошибок**: Отправьте некорректные данные и проверьте, правильно ли API обрабатывает ошибки.\n4. **Методы HTTP**: Проверьте поведение всех соответствующих методов HTTP (GET, POST, PUT, DELETE и т.д.).\n5. **Валидация данных**: Убедитесь, что API правильно обрабатывает данные различных форматов, размеров и структур.\n6. **Авторизация и аутентификация**: Убедитесь, что API правильно реализует и применяет меры безопасности.\n### SOAP API\n- SOAP API также не хранит состояние и может быть протестирован на основе операций.\n- Учитывая, что SOAP API используют XML, проверки обычно выполняются для xml ответов.\n- Для тестирования часто используются такие инструменты, как SoapUI. Можно проводить контрактное тестирование, поскольку SOAP API четко определены в WSDL.\n\nХотя SOAP API обычно использует полезную нагрузку XML и является более подробным, Postman может работать и с ним. Для тестирования SOAP API можно отправить POST-запрос на эндпоинт SOAP с телом XML и заголовками (например, Content-Type: text/xml), установленными соответствующим образом.\n\nШпаргалки для тестировщика\n1. **WSDL-файл**: Проверьте WSDL-файл на наличие синтаксических ошибок или несоответствий.\n2. **Запросы/ответы SOAP**: Убедитесь, что запросы и ответы SOAP правильно отформатированы.\n3. **Обработка ошибок**: Убедитесь, что API корректно возвращает ошибки для невалидных запросов.\n4. **Валидация данных**: Проверьте способность API обрабатывать данные различных форматов, размеров и структур.\n5. **Безопасность**: Убедитесь, что API правильно реализует стандарты WS-Security.\n\n### API WebSocket\n- Поскольку WebSockets обеспечивает полнодуплексную связь, тестирование может быть немного сложным. Необходимо протестировать подключение, отключение, отправку сообщений, получение сообщений и сценарии ошибок.\n- Для тестирования можно использовать инструменты Postman и WebSocket King или библиотеки websocket-client (Python) и WebSocket-Node (Node.js).\n\nВ версии 8.0 Postman представил поддержку WebSocket API. Вы можете отправлять запросы WS (WebSocket) и WSS (WebSocket Secure), а также вести историю переданных сообщений. С помощью WebSocket-соединений Postman позволяет отправлять и получать сообщения, отсоединяться и вновь подключаться к сокету, а также просматривать обновления состояния.\n\nШпаргалка для тестировщика:\n1. **Соединение**: Протестируйте функциональность подключения и отключения WebSocket.\n2. **Отправка/получение сообщений**: Убедитесь, что сообщения правильно отправляются и принимаются в режиме реального времени.\n3. **Обработка ошибок**: Проверьте способность API обрабатывать ошибки и неожиданные отключения.\n4. **Одновременные соединения**: Проверьте поведение при нескольких одновременных соединениях.\n5. **Формат данных**: Убедитесь, что API правильно обрабатывает данные в ожидаемом формате.\n### API gRPC\n- Учитывая, что gRPC использует HTTP/2, необходим инструмент, поддерживающий этот протокол. Буферы протокола (protobuf) также требуют специальной обработки.\n- Инструменты для тестирования включают grpccurl и ghz. Кроме того, юнит-тестирование можно выполнить с помощью различных библиотек, специфичных для данного языка.\n- Поскольку gRPC поддерживает четыре типа связи (унарная, серверная потоковая, клиентская потоковая и двунаправленная потоковая), требуется тестирование каждого из этих типов.\n\nPostman также позволяет тестировать gRPC, импортируя протофайл. Тестирование аналогично тестированию REST. \n\nШпаргалка для тестировщика:\n1. **Валидация сообщений Protobuf**: Убедитесь, что сообщения Protobuf структурированы и отформатированы правильно.\n2. **Унарные и потоковые вызовы**: Тестируйте как унарные вызовы, так и все три типа потоковых вызовов (сервер, клиент, двунаправленные).\n3. **Обработка ошибок**: Проверьте, как API обрабатывает некорректные запросы или данные.\n4. **Производительность**: Проверьте производительность API, особенно в сценариях с высокой нагрузкой.\n5. **Безопасность**: Проверьте реализацию в API аутентификации и шифрования на основе сертификатов.\n\n### API GraphQL\n- В отличие от REST и SOAP, GraphQL основан не на сервисах, а на схеме данных, что требует другого подхода в тестировании. По сути, вы проверяете правильность загрузки данных в соответствии с запросами и мутациями.\n- Для тестирования можно использовать такие инструменты, как Postman, Apollo Client Developer Tools или даже браузерные IDE, например GraphiQL\n- Также обычно тестируется избыток или недостаток данных (overfetching и underfetching), поскольку GraphQL позволяет клиентам точно указывать, какие данные им нужны.\n\nPostman имеет надежную поддержку GraphQL API. Вы можете отправлять запросы GraphQL в теле запроса, использовать переменные GraphQL и даже заполнять запросы в Postman автоматическим образом благодаря поддержке схем GraphQL. Postman также позволяет импортировать и проверять схемы GraphQL.\n\nШпаргалка для тестировщика:\n1. **Валидация запросов**: Убедитесь, что запросы возвращают правильные и ожидаемые данные.\n2. **Тестирование мутаций**: Проверьте, что мутации правильно создают или изменяют данные.\n3. **Обработка ошибок**: Убедитесь, что API корректно возвращает ошибки при некорректных запросах/мутациях.\n4. **Валидация данных**: Проверьте, как API работает с данными различных форматов, размеров и структур.\n5. **Избыточная и недостаточная выборка**: проверьте, могут ли клиенты правильно указать нужные им данные, без избыточной или недостаточной выборки.\n# Клиент-серверная архитектура\n**Web API** состоит из нескольких конечных точек для определенной системы сообщений \"запрос-ответ\".\n\n**Сервер** — удаленный узел, который хранит и обрабатывает ресурсы. Здесь мы храним необходимые данные, а также устанавливаем то, как они обрабатываются и предоставляются клиентам.\n\n**Клиент** — программа, которая изначально не хранит данные и запрашивает у сервера те самые ресурсы. В нашей схеме клиентом может выступить мобильное приложение, пользующееся ресурсами сервера. В ином случае, это например, может быть какой-либо сервис оплаты для интернет-магазинов или **веб-сайт нейросети, которая выдает результат по вашему запросу.**\n\n**Каждой функциональности в системе соответствует определенная конечная точка**, что обеспечивает четкую и модульную организацию функций. Одной из практик является использование _ресурсо-ориентированного подхода_, при котором такие объекты, как пользователи, журналы и другие объекты, рассматриваются как ресурсы (или коллекции ресурсов) с уникальными конечными точками для их получения/создания/обновления/удаления. **JSON** в свою очередь служит форматом обмена данными и представления упомянутых ресурсов, обеспечивающим легкую и человекочитаемую структуру. К тому же для сериализации и десериализации данных (преобразования в/из) JSON существует множество средств, способных помочь разработчикам.\n\nТаким образом, **клиент знает, как обращаться к серверу,** и запрограммирован обрабатывать ожидаемый результат, **а сервер знает, как отвечать клиенту,** и запрограммирован обрабатывать входные данные и формировать ответы.\n# Сравнительный анализ технологий для разработки API\n1. **Для оценки определяются критерии**, которые взвешиваются на основе их важности, что позволяет учитывать большее значение некоторых факторов в контексте требований и задач проекта.\n    \n2. **В системе оценок применяется числовая шкала от 1 до 5**, где каждое значение представляет собой качественную оценку (1 - “плохо”, 5 - “отлично”). При оценке допускается использовать дробные числа, придающие детализированный характер для учета нюансов различий в показателях и в достаточной мере позволяющие отобразить индивидуальные достоинства и недостатки каждого кандидата.\n    \n3. **Каждый выбранный фреймворк (технология) оценивается по заранее установленным критериям** с присвоением баллов по шкале. Для повышения обоснованности и надежности сравнительного анализа может проводиться обзор тематических исследований, отраслевых тенденций и эмпирических данных.\n    \n4. **Общий балл по каждой технологии рассчитывается путем суммы произведений оценки каждого критерия на его вес.** Так получится достигнуть того, что факторы, считающиеся более важными для проекта, вносят пропорционально больший вклад в итоговую оценку. Сумма взвешенных баллов дает общий суммарный балл, позволяющий провести количественное сравнение между оцениваемыми технологиями.\n    \n5. **Признавая достаточно субъективный характер некоторых критериев, при выставлении баллов учитывается авторское суждение**, особенно в тех областях, где качественные оценки по своей сути субъективны. Каждая оценка может быть сопровождена комментарием, в котором формулируется обоснование выставленной оценки, что позволит обеспечить прозрачность и лучшую интерпретируемость результатов.\n\nНапример, критериями выбора могут быть: масштабируемость, производительность, безопасность, функциональные возможности, кривая обучения.\n# В Python\nНа python api можно реализовать в том числе с помощью Django, Flask, FastAPI.\n\nЗапрос местонахождения МКС:\n```python\nimport requests\n\napi_url = 'http://api.open-notify.org/iss-now.json'\n\nresponse = requests.get(api_url)\n\nif response.status_code == 200:\n\tprint(response.text)\nelse:\n\tprint(response.status_code)\n```\nОтвет:\n```json\n{\"message\": \"success\", \"iss_position\": \n {\"longitude\": \"7.6753\", \"latitude\": \"50.2226\"}, \"timestamp\": 1668894374}\n```\n", "created_at": "2024-08-02T15:37:20.483Z", "updated_at": "2024-08-02T15:37:20.586Z", "category": 1, "creator": 1}}, {"model": "manual.category", "pk": 1, "fields": {"title": "123"}}]